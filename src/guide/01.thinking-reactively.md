---
title: 思考响应式(thinking reactively)
type: guide
order: 101
---

本章节覆盖
* 比较异步 JavaScript 的回调(callbacks)和基于 Promise(Promise-based)的解决方案
* 使用流(streams)，来对静态数据、动态数据，和时间限制(time-bound)的数据进行建模
* 使用可观察的流(observable streams)，以一种函数式的方式，来处理无时间限制(unbounded)的数据
* 考虑如何响应式地处理异步数据流组合

现在，在世界上某个地方，有人刚刚创建了一个的推文、股票价格刚刚下降、以及一个鼠标刚刚移动。这琐碎的数据点亮了互联网，并通过遍及全球的半导体传播到随处可见的地方。大量的数据在所有互相连接的设备间传递。这与你有什么关系？当你将代码推送到生产环境中时，此时将会在你的 JavaScript 应用程序中的管道上触发事件，这些事件需要预先做好准备，以及进行有效地处理。这产生了两个关键的挑战：可扩展性(scalability)和延迟(latency)。

随着接收到越来越多的数据，应用程序消耗或需要的内存量，将呈线性增长，或者，在最坏的情况下，将呈指数增长。这是可扩展性(scalability)的经典问题，并且尝试一次处理它，必定会导致用户界面（UI - user interface）变得无响应。按钮可能不再似乎起作用，梦幻般动画将变得拖沓，浏览器甚至可能会将页面标记为终止，这对于现代 web 用户来说是不可接受的。

这个问题虽然原本就有，然而，近年来，随着 JavaScript 应用程序需要处理的事件和数据的数量规模呈指数级增长，这就成为了新的问题。数据量太大，不能轻易地取出和存储在内存中以供使用。作为替代方案，我们必须建议从远程位置异步获取数据的方式，从而导致互联软件系统面临的另一个巨大挑战：延迟(latency)，会导致很难表达为代码。

虽然现代系统架构已经极大改善，包括更快的网络设备和高并发处理，然而，随着远程数据的复杂性增加，用于处理数据的库(library)和方式却并没有获得相应的发展。例如，当涉及从服务器获取数据或运行延迟计算时，我们大多数人仍然依赖回调(callbacks)的使用，当业务规则演变和变化时，又或者我们要解决的问题所涉及的数据不在一处，而是在几处不同的远程位置时，回调(callbacks)方式很快就将应用程序代码变得一团混乱。

解决方案不只是在于使用哪个库(library)，而是应该考虑此类问题的最佳配套范式。在本书中，你将首先了解两种新兴范式的基本原理：函数式编程（FP - functional programming）和响应式编程（RP - reactive programming）。令人兴奋的是，将两种范式组合在一起后的函数式响应编程（FRP - functional reactive programming），以及最终体现这种编程思维的代码，被称为 RxJS（或称为 rx.js）的库，这是有效处理异步(asynchronous)和基于事件的数据源(event-based data sources)的最佳配方。

我们规划的路线图包括多个部分。首先，我们会引导你去理解响应式的原则、当前的解决方案、这些方案的缺点，以及 RxJS 是如何改进的。怀着发现新事物的心态，你会深入了解 RxJS 的具体细节，并了解核心操作符(operators)，可以让你以一种简洁优雅的方式，来表现那些复杂的、有时间限制(bounded)数据或无时间限制(unbounded)数据的数据流。你将了解到，为什么 RxJS 是适用于任何体量的、基于事件驱动的应用程序的理想选择。在学习旅途中，你会逐渐找出真实世界中相应例子，印证如何使用这个库(library)，来将多个远程数据、自动完成输入字段、拖放、处理用户输入、创建响应式 UI、并行处理等等组合在一起。这些示例旨在帮助你在学习 RxJS 的最重要功能时缩小范围。最后，我们会所有这些新技术将汇集在一起​​，构建一个使用 React/Rx 混合架构的完整规模的 web 应用程序，来结束你的旅程。

本章的目标是对本书将要学习的主题进行广泛的了解。我们将重点关注当前解决方案的局限性，并指出有关 RxJS 如何解决这些问题。此外，你会学习如何将思维方式转变为流(streams)（也称为事件的函数式序列），在 RxJS 的内部，流(streams)是通过我们熟悉的模式（例如，迭代器模式和观察者模式）实现的。最后，我们将探讨 RxJS 编写异步代码的优势，减少使用回调(callbacks)引起的逻辑纠缠，这也可以扩展到任何量级的数据。了解这两个世界之间的差异至关重要，所以让我们开始吧。

## 同步计算 vs 异步计算

简单来说，将运行时中的同步代码与异步代码，进行分离的主要因素是延迟时间(latency)，也称为等待时间(wait time)。将时序以显式的编码形式表现出来，会使人感到难以理解。当自己书写的代码的顺序，和运行时的代码执行顺序完全同步，你就会很容易根据这些顺序，编写出合适的、易于理解的代码：“执行这段程序，然后立即执行另一段程序”。

但是，如今的计算世界还没有提供如此奢侈的处理能力。在这个高度互联的计算世界中，在发送消息和接受响应的同一时刻，也代表着应用程序能够在此时间范围内，同时去处理一些其他事情，例如，响应用户输入、处理数字、或者更新 UI。这更像是“做这个（等待一段不确定的时间）；然后做另一个”。让应用程序闲置，然后等待数据库返回查询结果、等待网络的响应、或者是等待用户完成操作，这些传统方式是不可接受的，因此需要你利用异步执行，以使应用程序始终处于积极响应的状态。这里的主要问题是，在长时间运行的过程中，阻塞用户操作是否是可接受的。

### 同步代码造成的问题

每个代码块在执行时，都必须等待前一个代码块执行完成，这就是同步执行。无须怀疑，这是目前实现代码最容易的方式，因为你将代码执行的重任，放在用户那边，必须等待用户的处理完成，才会同步执行代码。许多系统仍然以这种方式运行着，例如 ATM、销售点系统和其他一些简易终端。以这种方式编写代码，会更加易于理解、维护和调试；不幸的是，由于 JavaScript 的单线程本质，任何长执行时(long-running)任务，例如等待 AJAX 执行返回、完成一个数据库操作，都不应该是同步进行。这样做会造成非常糟糕的用户体验，因为整个应用程序都在等待数据加载过程中闲置，并浪费宝贵的计算循环(computing cycles)，等待期间还可以直接执行其他代码。这也将阻塞下一个执行过程中，那些你期望执行的所有其他任务，因为长时间的加载，从而导致不自然的应用程序体验，如图 1.1 所示。

在这种场景中，程序在处理 1 时产生一个阻塞调用(blocking call)，这意味着程序必须等待控制权重新返回给调用者(caller)（译者注：即 Program），以便可以继续执行处理 2。在查询机器和简易终端中，这种方式可能运行良好，但是，浏览器 UI 不应该以这种方式实现。不仅会造成糟糕的用户体验(user experience - UX)，而且在经过一定时间段后，浏览器可能会认为你的脚本无响应并终止。以下是一个「等待服务器响应，而导致应用程序阻塞」的 HTTP 请求的示例：

```
let items = blockingHttpCall('/data');
items.forEach(item => {
  // 处理每个 item
});
```

图 1.1 一个程序执行两个同步的处理(process)。这个场景中的，一个处理可以可以像函数调用一样简单，例如一个 I/O 处理，或者一个网络事务。当处理 1 执行时，就会阻塞其他处理执行。

更好的方式是，在等待响应(response)时，调用 HTTP 请求并执行其他操作。任务的长执行时(long-running)不是唯一的问题；就像我们之前提到的，鼠标移动还额外产生了快速连续的细粒度事件(fine-grained events)。无论是长等待时间(long wait time)，还是快速处理数百个细小的事件对象造成的等待，同步去处理所有这些造成的等待，将导致整个应用程序变得无响应。那么，你应该以哪种非阻塞(non-blocking)的方式，去处理这些类型的事件呢？幸运的是，JavaScript 提供了回调函数(callback functions)。

同步地加载服务器端数据，会停止程序执行。在当前，本质上数据并不重要；它只是与你的应用程序关联的一些通用示例数据。

### 通过使用回调函数，创建无阻塞代码

使用函数(function)作为回调(callback)，已经成为这么多年来，JavaScript 开发中的重要组成部分。到处都会用到这种方式，包括从鼠标点击、键盘输入，到处理远端 HTTP 请求、或者文件 I/O。JavaScript 作为一种单线程语言(single-threaded language)，需要这样一种结构，以保证适用于不同层面的场景。回调函数在创立之初，是用来解决完整操作的长执行时(long-running)的难题，允许你提供一个处理函数(handler function)，一旦数据准备就绪，JavaScript runtime 会调用此处理函数。与此同时，你的应用程序还能够继续执行其他的任务，如图 1.2 所示。

在图 1.2 中，JavaScript 中的回调函数，创建了一种控制反转(inversion of control)模式，即，等待合适的时机，触发处理函数回来调用应用程序，而不是应用程序直接调用函数。

和前面的代码不同，你不必等待阻塞的 HTTP 调用，使用异步（AJAX）请求的回调将创建一个控制反转，允许你的应用程序继续执行下一行代码。在这种意义下，控制反转是指，你的代码的某些部分接收来自运行时系统(runtime system)返回的控制流的方式。在这种情况下，当数据准备好可以被处理的时候，运行时(runtime)通过函数句柄(function handler)调用（或者将控制权返回给你），因此，这就是术语 callback 的由来。来看这段代码：

```
ajax(
  '/data', // 没有显式地返回值
  items => { // 回调函数声明
    // 在服务器获取数据之后，所有处理都在回调函数内部进行。
    items.forEach(item => {
      // 处理每个 item
    });
  }
);
beginUiRendering(); // 此函数在 AJAX 调用后立即开始执行。
```

回调函数允许你以异步的方式去执行代码，以便应用程序可以稍后再返回控制权给你。这样可以让程序在此期间，继续执行所有其他任务。在这个代码示例中，HTTP 请求函数在后台运行，并且立即将控制权返回给调用者，以便开始渲染 UI；只有在完全加载好 HTTP 响应后，才处理 items 的内容。这种行为是理想的，因为它释放了应用程序，以便继续处理其他后续任务（例如，加载网页的其余部分），如同当前示例所展示的那样。就像你将在本书中看到的，对于 I/O 绑定(I/O-bound)的运行方式（例如，从 web 或者数据库获取数据），使用异步代码是一种很好的设计。这样做的原因是，I/O 处理通常比所有其他类型的指令慢得多，所以我们允许它们在后台运行，因为它们的完成不依赖处理器循环(processor cycles)。

> 在 1.1.2 节的代码示例中，ajax() 的第二个参数是回调函数。在该代码中，如同本书的许多部分，我们使用了 ECMAScript 6 中的 lambda 表达式语法([1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions))，它提供了一种更简明扼要的调用函数方式。lambda 表达式也被称为箭头函数，与我们早已熟悉的匿名函数(anonymous function)调用类似。箭头函数和匿名函数的微小差别在于它内部的关键字 this 的指向。在极少数情况下，当 this 的值很重要时，我们会把它提取出来，并且改用匿名表达式。

### 理解时间和空间

当然，我们也可以停止应用程序，以等待异步函数响应，但是这样付出的是时间等待的代价。而同步的程序，我们可以直接推断出应用程序的状态，异步代码迫使我们要去推断出未来状态。这是什么意思呢？可以将状态简单地理解为，在任何时间点上，存储到变量中的所有信息的快照。通过顺序执行的语句(statement)，去创建和操作这些信息。同步代码可以被认为是一个以顺序的方式，一步接着一步地执行语句，就像图 1.3 所示。

图 1.3 同步代码是指，一步接着一步地、顺序地相继执行语句，每一步都依赖于前一步的执行。

在这个同步模型中，在任何一个时间节点上，都很容易确定变量的状态是什么，接下来会发生什么，这就是为什么同步代码会很容易编写和调试。但是，当每个任务具有不同的等待时间，或者在不同的时间完成的时候，很难保证它们协同运转。如果没有合适的方法和实践，那些无法预知终止时间的函数通常更难处理。当这种异步场景发生时，我们用于理解应用程序的心智模型，还需要相应地补偿这个额外维度。将图 1.3 与图 1.4 中的模型进行比较，不仅在垂直方向上，而且水平方向也有所扩展。

图 1.4 在异步执行中，按顺序调用的那些步骤不需要同时终止。因此，绝对无法保证的是，你能够在可以在步骤 2 中，使用依赖于步骤 1 中的数据。

此时此刻，如果步骤 1, 2 和 3 是互相独立的任务，那么以任何顺序执行它们都不是问题。但是，如果这些函数是共享所有全局状态的函数，那么它们的行为将由它们被调用的先后顺序或系统的全局状态决定。这些条件我们称之为外部副作用(side effect)，你将在第 2 章中了解更多信息；它们涉及需要读取或修改外部资源（如数据库，DOM，控制台等）的情况。具有外部副作用的函数，在以任意顺序运行时，无法保证最终的执行结果可靠。在函数式和响应式编程中，你将学习通过使用纯函数来最小化依赖外部带来的副作用，你将在本书中了解到，在处理异步代码时，这种方式是非常有利的。

所以，假设我们的函数是无外部副作用的，然而我们还有另一个重要的问题 - 时间。步骤 1, 2 和 3 可能会立即完成，也可能不完成，取决于具体运行机制的本质。主要的问题是我们如何保证，这些步骤以正确的顺序执行。由于你可能已经实现过很多次了，正确方式是将这些函数组合在一起，从而使上一个的输出成为下一个的输入，因此创建出一条链式的步骤。确保正确的步骤顺序的传统方法是，按序嵌套回调，并且应用程序的运行时(runtime)的模型类似于图 1.5。

图 1.5 为了保证步骤的正确顺序和异步调用的按序执行，每当长执行时(long-running)的操作终止时，我们就使用回调函数来接管应用程序的控制权。

毫无疑问，这种嵌套控制流程，比图 1.4 的同步线性模型难以理解。在图 1.5 中，步骤 1 首先执行，然后在完成时调用步骤 2；然后在完成时执行步骤 3，其余的步骤也依此类推。这表明，在这些步骤之间，存在时序依赖或时间耦合，这意味着，只有在上一个完成后，下一个才可以开始 - 这就像是将一条命令链。在这种情况下，回调函数用于响应之前触发的异步请求，并开始处理其数据。通常会用在执行顺序的 AJAX 请求时，但也可能用在那些掺杂了所有基于事件的系统中，无论是按键、鼠标移动、数据库读取和写入等；所有这些系统都会依赖回调。

### 回调(callback)是否变得无关紧要？

最简洁的答案是不。在处理与用户(users)或与外部服务(external services)的简单交互时，通过使用范式(paradigm)去解决基于事件(event-based)的代码或异步(asynchronous)的代码是没有必要的。如果你正在编写一个发出远端 HTTP 请求的简单脚本，RxJS 是大材小用，回调(callback)仍然是完美的解决方案。另一方面，当实现具有中高复杂度的状态机，例如动态用户界面(dynamic UI)或服务调度层(service orchestration)时，混合有函数式范式(functional paradigm)和响应式范式(reactive paradigm)的库(library)才能开始显耀发挥。其中一些例子可能需要协调几个业务流程的执行，这些业务流程需要使用多个微服务(microservices)，数据聚合(data mashups)，或者可能需要实现由页面上的多个小部件组成的富用户界面(rich UI)的功能，而这些小部件又彼此交互。

考虑从客户端加载来自不同远端服务器端点的数据的任务。要在它们之间进行协调，你需要几个互相嵌套的 AJAX 请求，其中每一步都包含着每个回调函数体(callback body)中的处理数据，以及使用这些数据去调用下一步的逻辑，如前面图 1.5 所示。以下是一个可能存在场景的解决方案，它需要使用三个回调函数组合在一起，来加载可能位于同一或不同主机(host)中的数据集，以及相关的元信息(meta-information)和文件：

```
ajax(
  '<host1>/items', // 加载要显示的所有 item
  items => {
    for (let item of items) {
      ajax(
        `<host2>/items/${item.getId()}/info`, // 对每个 item，都加载额外的元信息(meta-information)
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles); // 对每个元记录(meta record)，加载相关文件
        }
      );
    }
  }
);
beginUiRendering();
```

现在，尽管你可能认为这些（回调）代码看起来微不足道，但如果继续这种模式，我们将不断地陷入朝着水平方向嵌套调用 - 我们的模型开始朝着水平方向增长。这个趋势在 JavaScript 世界中被非正式地称为回调地狱(callback hell)，如果想要创建可维护且易于理解的程序，你需要不惜一切代价避免这种设计。这不仅仅是强调代码的简洁美学 - 将确保单独的异步操作，体现为毫无阅读难度的同步代码是很难的。同时这些代码中其实还有另一个隐藏的问题。你能猜出有什么问题吗？这个隐藏问题通常会出现于，在命令式代码块（类似 for...of）的同步工件中混杂着调用异步函数的代码。循环(loop)没有意识到这些调用中存在延迟，所以循环会不关心这些延迟调用而继续前进，这会很大程度上导致一些无法预测和难以诊断的错误。在这些情况下，可以通过在异步函数外部创建闭包来改善问题，以及使用 forEach() 而不是循环(loop)进行操作：

```
ajax(
  '<host1>/items',
  items => {
    items.forEach(item => { // 数组的 forEach() 方法会让每个 item 对象都处于正确的作用域中，从而让嵌套在函数内的 HTTP 调用获取到正确的 item。
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    });
  }
);
```

这也就是为什么在 RxJS 和一般的函数式编程(FP - functional programming)中，所有的循环都被消除的原因！相反，在第 4 章和第 5 章中，你将学习有关操作符(operators)的知识，使你能够利用纯函数来产生异步请求序列(sequences of asynchronous requests)，以保持所有的 information 变量都能够处于正确的作用域。回调的另一个很好的用法是，由基于 Node.js 事件触发器(event emitters) API 实现。接下来我们来了解事件触发器。

###  事件触发器(event emitters)

对于基于事件(event-based)的异步体系结构，事件触发器(event emitters)是一种很流行的机制。例如，DOM 就是最广为人知的事件触发器之一。在像 Node.js 这样的服务平台上，某些类型的对象会周期性地产生事件，这些事件又会产生函数调用。在 Node.js 中，EventEmitter 类(class)用于实现诸如 WebSocket I/O 或者文件读/写之类的 API，因此，如果你遍历目录然后找到关注的文件，某个对象就会发出(emit)引用此文件的事件，以便你执行后续任何额外的代码。

让我们实现一个简单的对象来稍微展示一下这个 API。考虑一个简单的计算器对象，可以发出(emit)像加法和减法这样的事件，你可以将任何自定义逻辑添加到这两个钩子函数(hook)中，如图1.6.

图 1.6 Node 触发器对象，其具体表现为一个简单的计算器，它暴露了两个事件：加法和减法

这里是一些计算器的加法事件和减法事件的代码：

```
const EventEmitter = require('events'); // 加载 events 模块

class Calculator extends EventEmitter {} // 创建一个自定义的触发器(emitter)

const calc = new Calculator();

// 处理加法事件(add event)
calc.addListener('add', (a, b) => {
  calc.emit('result’, a + b);
});

calc.addListener('subtract', (a, b) => {
  calc.emit('result', a - b);
});

calc.addListener('result', (result) => {
  console.log('Result: ' + result);
});

calc.emit('add', 2, 3); //-> 打印 'Result: 5'
calc.emit('subtract', 2, 3); //-> 打印 'Result: 1'
```

订阅一个事件触发器，是通过 addListener() 方法实现的，它允许你提供一个回调函数，以便在关注事件被触发的时候调用。不幸的是，与「使用回调(callback)处理来自多个组合资源的数据」的相比，事件触发器(event emitter)也具有所有相同的问题。总体而言，将嵌套的异步流组合起来是很困难的。

整个 JavaScript 社区在解决这些类型的问题方面取得了很大幅度的进步。借助于函数式编程(FP - functional programming)中出现的模式，你可以使用 ES6 提供的替代方案，也就是 Promise。

## 更好的回调(callback)解决方案 Promise

回调(callback)并非毫无希望的，我们还有 Promise。Promise 不是 RxJS 解决方案的一部分，但是它们能够很好地协同工作。JavaScript ES6 引入了 Promise 这个概念，来指代将来可能完成的所有异步计算。通过 Promise，可以将获取未来值的一些操作链在一起，形成一种延续调用的格式(continuation)。延续(continuation)只是编写回调的一个华丽术语，并且与我们前面引用的控制反转(Inversion of Control)原理有很大关系。延续（一个回调）允许函数决定下一步应该做什么，而不是漫无目的地等待着返回值。在遍历数组、树形结构，try/catch 块，当然还有异步编程时，延续(continuation)会被大量使用。所以，你之前看到的代码 -

```
ajax(
  '<host1>/items',
  items => {
    for (let item of items) {
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    }
  }
);
```

- 被称为延续传递风格(continuation-passing style - CPS)，因为没有一个函数在直接地等待返回值。但正如我们所提到的，滥用这种方式会让代码难于推断。然而，其实你可以让延续成为一等公民(first-class citizens)，并且实际上将延续理解为“继续(continue)”这个具体概念。因此，我们引入然后(then)这个概念：“完成 X，然后再完成 Y”，让我们创建如下内容的可读代码：

```
Fetch all items, then（获取所有 items，然后） // 关键词 “then” 暗示了执行的时间和顺序。
  For-each item fetch all files, then（获取每个 item 的所有文件，然后）
    Process each file（处理每个文件）
```

这就是 Promise 的使用场景。Promise 是一种数据类型，它包裹了一个异步或长执行时(long-running)的操作、一个未来值，能够让你订阅它的结果(result)或错误(error)。当一个 Promise 的基本操作完成时，会被认为是完成状态(fulfilled)，与此同时，订阅者将收到计算结果(computed result)。只要某个 Promise 被执行，我们就无法改变它的值，它实际上是一种不可变类型(immutable type)，这是我们在编程中寻求的一种函数式特性(functional quality)。现有的不同 Promise 实现基于 Promises/A+ 协议（请查看 https://promisesaplus.com/ ），它旨在通过 then() 方法提供某些级别的错误处理(error handling)和延续(continuations)。如果假定 ajax() 返回 Promise，那么可以如下处理相同的示例：

```
ajax('<host1>/items')
  .then(items =>
    items.forEach(item =>
      ajax(`<host2>/data/${item.getId()}/info`)
        .then(dataInfo =>
          ajax(`<host3>/data/files/${dataInfo.files}`)
        )
        .then(processFiles);
    )
  );
```

这看起来和之前的语句没什么区别！作为对 ES6 语言的较新补充，Promise 的灵感来源于函数式编程(FP)设计，而比起回调(callback)来说，其显得更加全能通用和符合习惯。声明式(declaratively)地使用这些函数 - 意味着你的代码表达了你正在试图完成什么目的，而不是具体如何实现 - 在 then 代码块中允许你以纯方式(pure manner)表达副作用(side effect)。为了更具说明性，我们将通过重构以上代码，每个 ajax 都提取为独立函数。

```
let getItems = () => ajax('<host1>/items');
let getInfo = item => ajax(`<host2>/data/${item.getId()}/info`);
let getFiles = dataInfo => ajax(`<host3>/data/files/${dataInfo.files}`);
```

然后，使用 Promise 将我们的异步流程缝合在一起。我们使用 Promise.all() 函数将一个由各个 Promise 组成的数组，映射到包含结果数组的单个 Promise。

```
getItems()
  .then(items => items.map(getInfo))
  .then(promises => Promise.all(promises))
  .then(infos => infos.map(getFiles))
  .then(promises => Promise.all(promises))
  .then(processFiles);
```

then() 这种使用方式，显式地暗示了在这些调用中涉及时间，这是一件非常好的事情。如果任何一步失败，我们也可以使用对应的 catch() 块来处理错误，并且，在必要时还可能继续执行命令链，如图 1.7 所示。

Promise 建立了一种流程，即由 then 方法组成的调用链。如果 Promise 是 `fulfilled` 状态，函数链将继续；否则，错误被委托给 Promise 的 catch 块。

当然，Promise 也有缺点，否则我们不会谈论 Rx。使用 Promise 的缺点是它们无法处理产生多个值的数据源，如鼠标移动或文件流中的字节序列。而且，Promise 缺乏在失败时重试的能力 - 所有这些都出现在 RxJS 中。而且，最重要的缺点是，由于 Promise 是不变的，所以不能被取消。因此，举例说明，如果使用 Promise 来包裹远程 HTTP 调用的值，则无法以任何钩子或机制来取消。这是不幸的，因为基于 XmlHttpRequest 对象的 HTTP 调用可以被中止(abort)，但是这个特性不能通过 Promise 接口实现。这些限制减少了它们的使用场景，并迫使开发人员自己编写一些取消逻辑或寻求其他库(library)。

总体来说，Promise 和事件触发器(event emitter)通过稍微不同的方式来解决本质上相同的问题。它们有着不同的用例（Promise 用于返回单个值，例如 HTTP 请求，以及事件触发器用于返回多个值，例如鼠标点击处理函数），主要由于它们自身实现所限制，而不是因为用例不同。结果是，在许多情况下，开发人员必须同时使用这两者才能达到目标，这往往会导致代码杂乱和困惑。

可读性的问题、难以理解的代码、目前的技术缺陷，这些我们已经讨论过的，并不是我们作为开发人员需要担心异步代码的仅有原因。在下一节中，我们将更具体地概述，为什么我们需要转向不同的范式来解决这些问题。

多年来，我们学会了使用许多 JavaScript 异步库，每个人都有自己的偏好，无论是 jQuery，Async.js，Q.js 还是其他人，然而他们往往欠缺于其他异步方式。我们认为，这不仅仅是要选择哪个库(library)的问题，而是要去选择正确的范式。通过结合函数式和响应式编程范式，RxJS 将帮助你解决以下问题：

* 我们熟悉的控制流结构（如 for 和 while 循环），与异步函数无法很好地协同工作，因为流控制结构无法意识到这些函数是异步的。也就是说，他们不知道要去等待每次迭代的时间或延迟。
* 在每个回调中嵌套 try/catch 块时，错误处理策略极有可能变得非常复杂。在第 7 章中，我们将从函数式的角度来着手错误处理。另外，如果你想在每一步都实现一些级别的重试逻辑，即使在其他库的帮助下，这也是非常困难的。
* 业务逻辑紧密耦合在你需要支持的嵌套回调结构中。很明显，你的代码越是嵌套，就越难推断其中的逻辑。深度嵌套的函数与其他变量和函数纠缠在一起，这在可读性和复杂性方面是有问题的。理想的情况下，为了能够将耦合在一起的业务逻辑变得松散，我们会创建可复用和模块化的组件，以便于维护和独立进行单元测试。我们将在第 9 章介绍 RxJS 的单元测试。
* 你希望避免过度使用闭包，但是 JavaScript 中的函数会在声明的位置，所处的作用域内创建闭包。嵌套它们意味着你不仅需要关心作为参数传入的变量的状态，还要关心每个函数声明周围的所有外部变量的状态，从而引起副作用。在下一章中，你将学习副作用是如何有害于状态的，以及函数式编程(FP)如何解决这个问题。副作用会增加应用程序状态的认知负担，使你无法追踪程序中正在发生的事情。将几个循环和 if-else 条件语句混合使用后，你将会遗憾于由于影响到了函数的函数性，以致于一整天都遇到 bug。
* 当事件或长执行时(long-running)操作迟迟不返回时，这种情况很难察觉并且需要取消。考虑这样一种情况，花费太久时间的远程 HTTP 请求，现在需要我们处理。是脚本没有响应，又或者服务器响应很慢？理想的情况下，有一种简单的机制，在超过事先指定的时间后，干净利落地取消事件。即使在第三方库(library)的帮助下，实现自己的取消机制也是非常具有挑战性和易于出错的。
* 响应式设计的一个好的特性是，始终对任何 UI 组件的用户交互进行节流(throttle)，这样系统就不会承载太多不必要的交互。在第 4 章中，你将学习如何使用节流(throttle)和去抖(debounce)来获得优化。为实现这一目的，手动编写解决方案，通常很难做到非常合理，并且涉及到函数要访问它们的局部作用域外部的数据，这会破坏整个程序的稳定性。
* 很少需要关心 JavaScript 应用程序中的内存管理，特别是客户端代码。毕竟，浏览器会处理大部分这些底层细节。但随着用户界面变得越来越重，我们可以开始看到，遗留的事件监听器可能会导致内存泄漏，并导致浏览器进程的大小增加。确实，这在老版本的浏览器中非常普遍；与此同时，当前的 JavaScript 应用程序的复杂程度，也远超以往的应用程序。

即使是最聪明的开发者，肯定也会被淹没在这个很长的问题列表中。事实真相是，帮助我们解决这些问题的范式，很难通过代码表述出来，这就是为什么有必要借助于类似 RxJS 这样的工具，来重新定义我们的开发方式。

你已经了解到 Promise 确实是朝着正确的方向发展（如果你觉得有需求，RxJS 可以与 Promise 无缝集成在一起）。然而，你真正需要的是一种解决方案，将延迟的概念从代码中中抽象出来，数据可以随着时间流动，生成线性的步骤序列(linear sequence of steps)，以此来对你的解决方案进行建模，如图 1.8 所示。

实质上，你需要将分离的功能组合起来，例如具备通顺易于理解的设计模式的事件触发器 Promise，形成一种独立抽象。而且，你需要同时使用同步代码和异步代码，处理错误，消除副作用，以及能够处理一个事件，甚至延伸到处理一系列事件。这确实是个需要关注的巨量清单。

随着你思考于此处，问自己这些问题：如何将代码编写成一个线性的步骤序列(linear sequence of steps)，只有在将来发生了一些事件之后才产生行为。如何将这些代码与可能有着内在约束逻辑的其他代码结合起来使用？对同步的渴望，不仅是要求方便，同时也要符合你的习惯。不幸的是，大多数常见语言结构，并不适合在同步代码中使用的异步执行。缺乏语言级别的支持，例如异步 try/catch、异步循环语句和异步条件语句等，意味着开发人员必须经常从自己的语言反复翻捡相应的语法。毋庸置疑，在过去几年中，一些人也提出了同样的问题，并与整个社区共同应对这些挑战，这就是所谓响应式扩展(Reactive Extensions)的新兴理念 - 我们已经找到了解决思路！

图 1.8 RxJS 能够处理异步的数据流，通过类似于将序列的步骤(sequential steps)组成链式这种编程模型。

## JavaScript 实现的响应式扩展(Reactive Extensions)

JavaScript 实现的响应式扩展(RxJS)，是可以优雅地替代回调(callback)或基于 Promise(Promise-based) 的库，使用统一的编程模型处理无处不在的事件源 - 无论是读取文件、创建 HTTP 调用、点击按钮或移动鼠标 - 都以完全相同的处理方式。例如，不通过回调处理每个独立的鼠标事件，而是使用 RxJS 将这些事件组合起来统一处理。

正如你将在第 9 章学习到的知识，由于有着充满活力的社区，RxJS 的内在非常健壮，并且易于测试。RxJS 的实力来源于函数式编程和响应式编程的鼎力支持，以及一些成熟多年的流行设计模式，例如观察者模式(observer)和迭代器模式(iterator)。当然，RxJS 并没有发明这些模式，但是它找到了在函数式编程(FP)中使用它们的方法。我们将在下一章进一步讨论函数式编程(FP)，及其在 RxJS 中的作用；为了充分利用这个框架，本节的关键卖点是你必须学会​​从流(stream)这一角度来思考。

### Thinking in streams: data flows and propagation

Whether you deal with thousands of key presses, movement events, touch gestures, remote HTTP calls, or single integers, RxJS treats all of these data sources in exactly the same way, which we’ll refer to as data streams from now on.

> Traditionally, the term stream was used in programming languages as an abstract object related to I/O operations such as reading a file, reading a socket, or requesting data from an HTTP server. For instance, Node.js implements readable, writable, and duplex streams for doing just this. In the RP world, we expand the definition of a stream to mean any data source that can be consumed.

Reactive programming entails a mental shift in the way you reason about your program’s behavior, especially if you come from an imperative background. We’ll illustrate this shift in mindset with a simple exercise:

```
let a = 20;
let b = 22;
let c = a + b; //-> 42

a = 100;
c = ?
```

You can easily predict the value of c in this case: 42. The fact that we changed a didn’t have any influence on the value of c. In other words, there’s no propagation of change. This is the most important concept to understand in reactive programming. Now we’ll show you a pseudo JavaScript implementation of this:

```
A$ = [20]; B$ = [22]; // Creates a stream initialized with the value 22

C$ = A$.concat(B$).reduce(adder); //-> [42] // Concatenates both streams and applies an adder function to get a new container with 42

A$.push(100); // Pushes a new value into A$
C$ = ?
```

First, we’ll explain some of the notation we use here. Streams are containers or wrappers of data very similar to arrays, so we used the array literal notation [] to symbolize this. Also, it’s common to use the $ suffix to qualify variables that point to streams. In the RxJS community, this is known as Finnish Notation, attributed to Andre Staltz, who is one of the main contributors of RxJS and Finnish.

We created two streams, A$ and B$, with one numerical value inside each. Because they’re not primitive objects in JavaScript or have a plus (+) overloaded operator, we need to symbolize addition by concatenating both streams and applying an operator method like reduce with an adder function (this should be somewhat familiar to you if you’ve worked with these array methods). This is represented by C$.

JavaScript ES5 introduced new array methods, known as the array extras, which enable some level of native support for FP. These include map, reduce, filter, some, every, and others.

> ARRAY EXTRAS - What happens to C$ if the value 100 is pushed onto A$? In an imperative program, nothing will actually happen except that A$ will have an extra value. But in the world of streams, where there’s change propagation, if A$ receives a new value (a new event), this state is pushed through any streams that it’s a part of. In this case, C$ gets the value 122. Confused yet? Reactive programming is oriented around data flows and propagation. In this case, you can think of C$ as an always-on variable that reacts to any change and causes actions to ripple through it when any constituent part changes. Now let’s see how RxJS implements this concept.

What happens to C$ if the value 100 is pushed onto A$? In an imperative program, nothing will actually happen except that A$ will have an extra value. But in the world of streams, where there’s change propagation, if A$ receives a new value (a new event), this state is pushed through any streams that it’s a part of. In this case, C$ gets the value 122. Confused yet? Reactive programming is oriented around data flows and propagation. In this case, you can think of C$ as an always-on variable that reacts to any change and causes actions to ripple through it when any constituent part changes. Now let’s see how RxJS implements this concept.

### Introducing the RxJS project

RxJS is the result of many efforts to manage the myriad of problems that manifest in asynchronous programming, outlined earlier. It’s an open source framework ported by Matthew Podwysocki from Rx.Net (Reactive Extensions for .Net), itself open source and created by Microsoft. RxJS has now evolved as a community-driven project owned by Ben Lesh from Netflix, sanctioned by Microsoft as RxJS 5. This latest version is a complete overhaul of the previous version with a brand-new architecture, a laser focus on performance, and drastic simplification of the API surface. It offers several distinct advantages over other JavaScript solutions, because it provides idiomatic abstractions to treat asynchronous data similar to how you would treat any source of synchronous data, like a simple array. You can obtain installation details in appendix A.

If you were to visit the main website for the Reactive Extensions project (http:// reactivex.io/), you’d find it defined as “an API for asynchronous programming with observable streams.” By the end of this chapter, you’ll be able to parse out exactly what this means. We’ll demystify this concept and put you on the right path to tackle the problems presented in this book.

Let’s see what thinking in streams looks like more concretely in RxJS. In figure 1.9, we show a simple breakdown of a stream (or pipeline) approach to handling data. A pipeline is a series of logic blocks that will be executed, in order, when data becomes available. 4 On the left side of figure 1.9 are the data sources, which produce various forms of data to be consumed by an application. And on the right are the data consumers, the entities that subscribe to (or listen for) these events and will do something with data they receive, such as present it on a chart or save it to a file. In the middle is the data pipeline. During this middle step, data that’s coming from any of the data sources that are being observed is filtered and processed in different ways so that it can be more easily consumed by the consumers.

Figure 1.9 A generic data-processing pipeline deals with a constant stream of asynchronous data, moving it from a producer (for example, a user clicking the mouse) to a consumer (code that reacts to the click). The pipeline will process data before it’s passed to the consumer for consumption.

You can subscribe to streams and implement functions within the pipeline that will be called (therefore react) when an event occurs (it’s this pipeline component where the principles of FP will come into play, as you’ll learn about in chapter 2).

> DEFINITION - A stream is nothing more than a sequence of events over time.

A popular example that you can relate to would be an Excel spreadsheet. You can easily bind functions onto cells that subscribe to the values of other cells and respond in real time as soon as any of the bounded cells change. A stream is an abstract concept that works exactly like this, so we’ll slowly wind up to it and break it down starting with some popular constructs you’re familiar with.

### Everything is a stream

The concept of a stream can be applied to any data point that holds a value; this ranges from a single integer to bytes of data received from a remote HTTP call. RxJS provides lightweight data types to subscribe to and manage streams as a whole that can be passed around as first-class objects and combined with other streams. Learning how to manipulate and use streams is one of the central topics of this book. At this point, we haven’t talked about any specific RxJS objects; for now, we’ll assume that an abstract data type, a container called Stream, exists. You can create one from a single value as such:

```
Stream(42);
```

At this point, this stream remains dormant and nothing has actually happened, until there’s a subscriber (or observer) that listens for it. This is very different from Promises, which execute their operations as soon as they’re created. Instead, streams are lazy data types, which means that they execute only after a subscriber is attached. In this case, the value 42, which was lifted into the stream context, navigates or propagates out to at least one subscriber. After it receives the value, the stream is completed:

```
// Using a simple function that will be called with each event in the stream
Stream(42).subscribe(
  val => {
    console.log(val); //-> prints 42
  }
);
```

> Observer pattern

> Behind RxJS is a fine-tuned observer design pattern. It involves an object (the subject), which maintains a list of subscribers (each an observer) that are notified of any state changes. This pattern has had many applications, especially as an integral part of the model-view-controller (MVC) architecture where the view layer is constantly listening for model changes. But the rudimentary observer pattern has its drawbacks because of memory leaks related to improper disposal of observers. You can learn more about this in the famous book Design Patterns: Elements of Reusable Object-Oriented Software, known casually as the Gang of Four book.

> RxJS draws inspiration from this pattern for its publish-subscribe methodology targeted at asynchronous programs but adds a few extra features out of the box, like signals that indicate when a stream has completed, lazy initialization, cancellation, resource management, and disposal. Later on, we’ll talk about the components of an RxJS stream.

> ---

> a. Gamma, Helm, Johnson, and Vlissides (Addison-Wesley, 1977, Oxford University Press).

Furthermore, you can extend this example to a sequence of numbers

```
Stream(1, 2, 3, 4, 5).subscribe(
  val => {
    console.log(val);
  }
);
//-> 1
     2
     3
     4
     5
```

or even arrays:

```
// Streams also support the Array.map() and Array.filter() functions introduced in ES5 to process the contents within the array.
Stream([1, 2, 3, 4, 5])
  .filter(num => (num % 2) === 0)
  .map(num => num * num)
  .subscribe(
    val => {
      console.log(val);
    }
  );
//-> 4
     16
```

In this example, the set of operations that occurs between the creation of the producer of the stream (in this case, the array) and the consumer (the function that logs to the console) is what we’ll refer to as the pipeline (we’ll expand on these concepts shortly). The pipeline is what we’ll study thoroughly in this book and is what allows you to transform a given input into the desired output. In essence, it’s where your business logic will be executed, as outlined in figure 1.10.

Figure 1.10 A simple producer (an array of numbers) that emits events linearly. These events are submitted through the pipeline and transformed. The final data is then sent to all subscribers to be consumed.

Up until now, we’ve created streams from static data sources: numbers (or strings), sequences, and arrays. But the power of RxJS extends beyond that with the ability to treat dynamic data sources in exactly the same way, as if time didn’t factor into the equation.

### Abstracting the notion of time from your programs

Indeed, time is of the essence. The hardest part of asynchronous code is dealing with latency and wait time. You saw earlier how callbacks and Promises can be used to cope with these concerns, each with their own limitations. RxJS brings this notion of continuous sequences of events over time as a first-class citizen of the language - finally, a true event subsystem for JavaScript. In essence, this means that RxJS abstracts over time under the same programming model regardless of source, so that you can transform your data as if your code was completely linear and synchronous. This is brilliant because you now can process a sequence of mouse events just as easily as processing an array of numbers.

Looking at figure 1.11, you can see that streams are analogous to a real-world monthly magazine subscription. Your subscription to the magazine is actually a collection of magazines that are separated by time; that is, there are 12 magazines annually, but you receive only one every month. Upon receiving a magazine, you usually perform an action on it (read it or throw it away). There are additional cases that you can also consider, such as the time between magazine deliveries being zero, whereby you would receive all the magazines at once, or there might be no magazines (and someone would be getting an angry email). In all these cases, because you perform the action only upon receiving the magazine, you can think of this process as reactive (because you’re reacting to receiving a magazine). A non-reactive version of this would be going to a newspaper stall at the airport. Here, you can also find magazines, but now you won’t receive additional magazines, only the ones that you buy at the stall. In practice, this would mean that you receive updates only when you happen to be near a magazine stand rather than every time a new magazine becomes available.

Figure 1.11 Not only does RxJS handle sequential events, but using the same programming model, it can just as easily work with asynchronous events (bound by time). This means that the same level of reasoning applied to linear programs can also be applied to non-linear programs with latency and wait times.

Rx allows you to take this magazine subscription metaphor and apply it to a wide range of use cases: loading files from disk or over a network, processing user input, or handling real-time services like RSS and Twitter feeds. Following the same examples as before, with RxJS you can consume a stream of time-based asynchronous sequences of events, just as you did with normal synchronous data:

```
// Using the well-known Array.filter() operator, this time with magazine subscriptions, to retrieve only the July edition
Stream(loadMagazines('/subscriptions/magazines'))
  .filter(magazine => magazine.month === 'July')
  .subscribe(
    magazine => {
      console.log(magazine.title);
      //-> prints Dr. Dobbs "Composing Reactive Animations"
    }
  );
```

These types of services produce data in real time at irregular intervals, and the data produced forms the foundation of an event stream. In the case of a service like Twitter, you can think of the Twitter API as a producer of tweets, of which some will be interesting and some not so much. In general, in most cases you’re interested in creating logic that processes the content of the tweet rather than diving into the intricacies of network communication. As we mentioned earlier, this logic is made up of several components, which we’ll look at in more detail.

### Components of an Rx stream

The RxJS stream is made up of several basic components, each with specific tasks and lifetimes with respect to the overall stream. You saw some examples of these earlier, and now we’ll introduce them more formally:

* Producers
* Consumers
* Data pipeline
* Time

PRODUCERS

Producers are the sources of your data. A stream must always have a producer of data, which will be the starting point for any logic that you’ll perform in RxJS. In practice, a producer is created from something that generates events independently (anything from a single value, an array, mouse clicks, to a stream of bytes read from a file). The observer pattern defines producers as the subject; in RxJS, we call them observables, as in something that’s able to be observed.

Observables are in charge of pushing notifications, so we refer to this behavior as fire-and-forget, which means that we’ll never expect the producer to be involved in the processing of events, only the emission of them.

> TC-39 OBSERVABLE SPEC - The use of observables has proven to be so successful from the previous version of the library (RxJS 4) that a proposal has been made to include it in the next major release of JavaScript. 5 Fortunately, RxJS 5 follows this proposal closely to remain completely compatible.

CONSUMERS

To balance the producer half of the equation, you must also have a consumer to accept events from the producer and process them in some specific way. When the consumer begins listening to the producer for events to consume, you now have a stream, and it’s at this point that the stream begins to push events; we’ll refer to a consumer as an observer.

Streams travel only from the producer to the consumer, not the other way around. In other words, a user typing on the keyboard produces events that flow down to be consumed by some other process. This means that part of understanding of how to think in streams will mean understanding how to think about parts of an application as upstream or downstream to determine the direction in which the data will flow. With respect to RxJS, a stream will always flow from an upstream observable to a downstream observer, and both components are loosely coupled, which increases the modularity of your application, as shown in figure 1.12.

Figure 1.12 Events always move from observables to observers and never the other way around.

For instance, a keyboard event handler would be upstream because it would only produce events, not consume them, whereas code that should perform logic based on key presses would be downstream. At a fundamental level, a stream will only ever require the producer and the consumer. Once the latter is able to begin receiving events from the former, you have effectively created a stream. Now what can you do with this data? All of that happens within the data pipeline.

DATA PIPELINE

One advantage of RxJS is that you can manipulate or edit the data as it passes from the producer to the consumer. This is where the list of methods (known as observable operators) comes into play. Manipulating data en route means that you can adapt the output of the producer to match the expectations of the consumer. Doing so promotes a separation of concerns 6 between the two entities, and it’s a big win for the modularity of your code. This design principle is typically extremely hard to accomplish in large-scale JavaScript applications, but RxJS facilitates this model of design.

TIME

The implicit factor behind all of this is time. For everything RxJS there’s always an underlying concept of time, which you can use to manipulate streams. The time factor permeates all the components we’ve discussed so far. It’s an important and abstract concept to grasp, so we’ll look at it in detail in later chapters. For now, you need only understand that time need not always run at normal speed, and you can build streams that run slower or faster depending on your requirements. Luckily, this won’t be an issue if you decide to use RxJS. Figure 1.13 provides a visualization of the parts of the RxJS stream.

Figure 1.13 Sample code highlighting the different components of a stream

If you pay close attention to the structure of a stream, you’ll notice that this closely resembles the pattern used in Promises. What started out as a nested callback “pyramid of doom”

```
ajax(
  '<host1>/items',
  items => {
    items.forEach(item => {
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    });
  }
);
```

was drastically improved using Promises:

```
ajax('<host1>/items')
  .then(items =>
    items.map(item => ajax(`<host2>/data/${item.getId()}/info`)
  )
  .then(promises =>
    Promise.all(promise)
  )
  .then(dataInfo =>
    ajax(`<host3>/data/files/${dataInfo.files}`)
  )
  .then(promises => Promise.all(promises))
  .then(processFiles);
```

And now, streams extend this behavior with powerful operators that break this down even further:

```
// Streams can also compose other streams.
Stream(ajax('<host1>/items')
  .streamMap(item =>
    Stream(ajax(`<host2>/data/${item.getId()}/info`)))
  .streamMap(dataInfo =>
    Stream(ajax(`<host3>/data/files/${dataInfo.files}`)))
  .subscribe(processFiles);
```

Remember that the Stream object here is merely an abstract artifact designed to show you how the paradigm works. In this book, you’ll learn to use the actual objects that implement these abstract concepts to design your applications using a functional and reactive model. But RxJS doesn’t obligate you to use only a single paradigm; it’s often the combination of paradigms that creates the most flexible and maintainable designs.

## Reactive and other programming paradigms

Every new paradigm that you’ll encounter during your programming career will require you to modify your thinking to accommodate the primitives of the language. For example, object-oriented programming (OOP) puts state within objects, which are the central units of abstraction, and the intricacy of the paradigm comes from the interactions that arise when they interact with one another. In a similar fashion, FP places behavior at the center of all things, with functions as the main unit of work. Reactive programming, on the other hand, requires you to see data as a constantly flowing stream of change as opposed to monolithic data types or collections holding all of an application’s state.

Now you’re probably wondering, am I allowed to choose only one? Or can I combine them into the same code base? The beauty behind all this is that you can use all of them together. Many prominent figures in our industry have attested to this. In other words, RxJS doesn’t force on you a certain style of development or design pattern to use - it is unopinionated. Thankfully, it also works orthogonally to most libraries. As you’ll see later on, it’s a simple matter in most cases to adapt an existing event stream such as a DOM event handler into an observable. The library provides many operators for such operations baked directly into it. It will even support unusual design patterns such as those you’ll see when you use a library like React or Redux (which you’ll see in the last chapter).

In practice, you can use OOP to model your domain and use a powerful combination of reactive and FP (a combination known as functional reactive programming) to drive your behavior and events. When it comes to managing events, you’ll soon begin to see an important theme in code involving Rx. Unlike in OOP where state or data is held in variables or collections, state in RP is transient, which means that data never remains stored but actually flows through the streams that are being subscribed to, which makes event handling easy to reason about and test.

Another noticeable difference is the style used in both paradigms. On one hand, OOP is typically written imperatively. In other words, you instantiate objects that keep track of state while running through a sequence of statements revealing how those objects interact and transform to arrive at your desired solution.

On the other hand, RxJS code encourages you to write declaratively, which means your code expresses the what and not the how of what you’re trying to accomplish. RxJS follows a simple and declarative design inspired by FP. No longer will you be required to create variables to track the progress of your callbacks or worry about inadvertently corrupting some closed-over outer state causing side effects to occur. Besides, with RxJS it becomes easy to manage multiple streams of data, filtering and transforming them at will. By creating operations that can be chained together, you can also fluently create pipelines of logic that sound very much like spoken sentences like this: “When I receive a magazine for the month of July, notify me.”

In this chapter, you learned how RxJS elegantly combines both functional and reactive paradigms into a simple computing model that places observables (streams) at the forefront. Observables are pure and free of side effects, with a powerful arsenal of operators and transformations that allow you to elegantly compose your business logic with asynchronous operations. We chose to keep the code abstract for now as we work through some of the new concepts. But we’ll quickly ramp up to a comprehensive theoretical and practical understanding of the library, so that you can begin to apply it immediately at work or on your personal projects. Now it’s time to start really thinking in streams, and that’s the topic of the next chapter.

## Summary

* Asynchronous code can be very difficult to implement because existing programming patterns don’t scale to complex behavior.

* Callbacks and Promises can be used to deal with asynchronous code, but they have many limitations when targeted against large streams generated from repeated button clicks or mouse movements.

* RxJS is a reactive solution that can more concisely and declaratively deal with large amounts of data separated over time.

* RxJS is a paradigm shift that requires seeing and understanding data in streams with propagation of change.

* Streams originate from a producer (observable), where data flows through a pipeline, arriving at a consumer (observer). This same programming model is used whether or not data is separated by time.
